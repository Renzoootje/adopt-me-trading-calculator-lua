local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local localPlayer = Players.LocalPlayer

print("Trade calculator script loaded")

-- Cached references
local ClientData, ItemDB
local last_successful_access_method = nil
local script_initialized = false

-- Safe table access
local function safe_get(tbl, ...)
    local current = tbl
    for _, key in ipairs({...}) do
        if type(current) ~= "table" or current[key] == nil then
            return nil
        end
        current = current[key]
    end
    return current
end

-- Safe instance access (GUI objects)
local function safe_instance_get(obj, ...)
    local current = obj
    for _, key in ipairs({...}) do
        if not current then return nil end
        if current:IsA("Instance") then
            current = current:FindFirstChild(key)
        elseif type(current) == "table" then
            current = current[key]
        else
            return nil
        end
    end
    return current
end

-- Get table keys
local function table_keys(tbl)
    local keys = {}
    if type(tbl) == "table" then
        for k, _ in pairs(tbl) do
            table.insert(keys, tostring(k))
        end
    end
    return keys
end

-- Initialization
local function initialize()
    if script_initialized then return true end
    print("Initializing trade calculator...")

    local start_time = tick()
    local Fsys

    while not Fsys and (tick() - start_time) < 15 do
        Fsys = ReplicatedStorage:FindFirstChild("Fsys")
        if not Fsys then wait(0.1) end
    end

    if not Fsys then warn("Fsys not found after 15 seconds") return false end

    local FsysModule
    local success = pcall(function() FsysModule = require(Fsys) end)
    if not success or not FsysModule then warn("Failed to load Fsys module") return false end

    local load
    if type(FsysModule) == "table" then
        local loaders = {"load","Load","require","getModule","get","fetch","Fetch"}
        for _, name in ipairs(loaders) do
            local f = safe_get(FsysModule, name)
            if type(f) == "function" then load = f break end
        end
        if not load then
            warn("No loader found in Fsys. Keys: " .. table.concat(table_keys(FsysModule), ", "))
            return false
        end
    end

    local max_attempts = 3
    for attempt = 1, max_attempts do
        print("Initialization attempt "..attempt.."/"..max_attempts)
        if not ClientData and load then pcall(function() ClientData = load("ClientData") end) end
        if not ItemDB and load then pcall(function() ItemDB = load("ItemDB") end) end

        if not ClientData then
            local CD = ReplicatedStorage:FindFirstChild("ClientData")
            if CD then pcall(function() ClientData = require(CD) end) end
        end
        if not ItemDB then
            local IDB = ReplicatedStorage:FindFirstChild("ItemDB")
            if IDB then pcall(function() ItemDB = require(IDB) end) end
        end

        if ClientData and ItemDB then break end
        wait(0.5)
    end

    if not ClientData then warn("Failed to load ClientData") return false end
    if not ItemDB then warn("Failed to load ItemDB") return false end

    script_initialized = true
    print("Trade calculator initialized successfully")
    return true
end

-- Sample values_data
local values_data = {
    ["0"] = {
        image="/images/pets/Hedgehog.png",
        rvalue=42.5,nvalue=176.0,mvalue=725.0,
        ["rvalue - nopotion"]=42.0,
        ["rvalue - ride"]=42.0,
        ["rvalue - fly"]=42.0,
        ["rvalue - fly&ride"]=42.5,
        ["nvalue - nopotion"]=181.0,
        ["nvalue - ride"]=177.0,
        ["nvalue - fly"]=177.0,
        ["nvalue - fly&ride"]=176.0,
        ["mvalue - nopotion"]=755.0,
        ["mvalue - ride"]=739.0,
        ["mvalue - fly"]=739.0,
        ["mvalue - fly&ride"]=725.0,
        rarity="ultra rare",
        type="pets",
        name="Hedgehog",
        id="0"
    }
}

local name_to_data = {}
for _, d in pairs(values_data) do
    if d.name then name_to_data[d.name] = d end
end

-- Trade data getter
local function get_trade_data()
    if not ClientData then return nil end

    if last_successful_access_method then
        local success, result = pcall(function()
            if last_successful_access_method.type=="property" then
                return ClientData[last_successful_access_method.key]
            elseif last_successful_access_method.type=="method" then
                return ClientData[last_successful_access_method.key](last_successful_access_method.param)
            end
        end)
        if success and result then return result end
        last_successful_access_method = nil
    end

    local direct_properties = {"trade","Trade","tradeData","TradeData","current_trade","currentTrade"}
    for _, prop in ipairs(direct_properties) do
        local value = safe_get(ClientData, prop)
        if value then
            last_successful_access_method={type="property", key=prop}
            return value
        end
    end

    local methods_and_params = {
        {"get","trade"},{"get","Trade"},
        {"Get","trade"},{"Get","Trade"},
        {"getData","trade"},{"getData","Trade"},
        {"GetData","trade"},{"GetData","Trade"},
        {"fetch","trade"},{"fetch","Trade"},
        {"Fetch","trade"},{"Fetch","Trade"},
        {"read","trade"},{"read","Trade"},
        {"Read","trade"},{"Read","Trade"},
        {"value","trade"},{"value","Trade"},
        {"Value","trade"},{"Value","Trade"}
    }

    for _, mp in ipairs(methods_and_params) do
        local method_name,param = mp[1], mp[2]
        local method = safe_get(ClientData, method_name)
        if type(method)=="function" then
            local success,result = pcall(function() return method(param) end)
            if success and result then
                last_successful_access_method={type="method", key=method_name, param=param}
                return result
            end
        end
    end

    return nil
end

-- Offers getter
local function getOffers(trade_state)
    if not trade_state then return nil,nil end
    local my_offer, partner_offer
    local sender = safe_get(trade_state,"sender")
    if localPlayer == sender then
        my_offer = safe_get(trade_state,"sender_offer")
        partner_offer = safe_get(trade_state,"recipient_offer")
    else
        my_offer = safe_get(trade_state,"recipient_offer")
        partner_offer = safe_get(trade_state,"sender_offer")
    end
    return my_offer, partner_offer
end

-- Total calculator
local function calculate_total(offer)
    if not offer then return 0 end
    local items = safe_get(offer,"items")
    if not items or type(items)~="table" then return 0 end

    local total = 0
    for _, item in ipairs(items) do
        if type(item)=="table" then
            local category, kind = safe_get(item,"category"), safe_get(item,"kind")
            if category and kind then
                local item_data = safe_get(ItemDB, category, kind)
                local item_name = item_data and safe_get(item_data,"name") or kind
                local data = safe_get(name_to_data, item_name)
                if data then
                    local value=0
                    if category=="pets" then
                        local base="rvalue"
                        local props=safe_get(item,"properties")
                        if props then
                            if safe_get(props,"mega_neon") then base="mvalue"
                            elseif safe_get(props,"neon") then base="nvalue" end
                        end
                        local suffix=" - nopotion"
                        if props then
                            local flyable, rideable = safe_get(props,"flyable"), safe_get(props,"rideable")
                            if flyable and rideable then suffix=" - fly&ride"
                            elseif flyable then suffix=" - fly"
                            elseif rideable then suffix=" - ride" end
                        end
                        value = safe_get(data, base..suffix) or safe_get(data, base) or 0
                    else
                        value = safe_get(data,"value") or 0
                    end
                    total = total + value
                end
            end
        end
    end
    return total
end

-- Update UI
local function updateUI(my_total, partner_total, diff)
    local trade_app = safe_instance_get(localPlayer,"PlayerGui","TradeApp")
    if not trade_app then return false end

    local neg_frame = safe_instance_get(trade_app,"Frame","NegotiationFrame")
    if not neg_frame then return false end

    local you_frame = safe_instance_get(neg_frame,"Header","YouFrame")
    if you_frame then
        local lbl = safe_instance_get(you_frame,"NameLabel")
        if lbl then pcall(function() lbl.Text="You ("..string.format("%.2f",my_total)..")" end) end
    end

    local partner_frame = safe_instance_get(neg_frame,"Header","PartnerFrame")
    if partner_frame then
        local lbl = safe_instance_get(partner_frame,"NameLabel")
        if lbl then pcall(function() lbl.Text="Partner ("..string.format("%.2f",partner_total)..")" end) end
    end

    local body = safe_instance_get(neg_frame,"Body")
    if body then
        local lbl = safe_instance_get(body,"NameLabel")
        if lbl then
            pcall(function()
                if diff>0 then
                    lbl.Text = "+"..string.format("%.2f",diff).." (You lose)"
                    lbl.TextColor3 = Color3.new(1,0,0)
                elseif diff<0 then
                    lbl.Text = "+"..string.format("%.2f",math.abs(diff)).." (You win)"
                    lbl.TextColor3 = Color3.new(0,1,0)
                else
                    lbl.Text = "Fair Trade"
                    lbl.TextColor3 = Color3.new(1,1,1)
                end
            end)
        end
    end
    return true
end

-- Track last diff
local last_my_total,last_partner_total,last_diff = nil,nil,nil

-- Main loop
local function main_loop()
    if not initialize() then wait(1) return end

    local trade_state = get_trade_data()
    if not trade_state then
        last_my_total,last_partner_total,last_diff=nil,nil,nil
        return
    end

    local my_offer,partner_offer = getOffers(trade_state)
    if not my_offer or not partner_offer then return end

    local my_total = calculate_total(my_offer)
    local partner_total = calculate_total(partner_offer)
    local diff = my_total - partner_total

    if my_total~=last_my_total or partner_total~=last_partner_total or diff~=last_diff then
        print(string.format("Trade update - You: %.2f | Partner: %.2f | Diff: %.2f",my_total,partner_total,diff))
        last_my_total,last_partner_total,last_diff=my_total,partner_total,diff
    end

    updateUI(my_total,partner_total,diff)
end

-- Connect to Heartbeat
RunService.Heartbeat:Connect(function()
    pcall(main_loop)
end)

-- Immediate initialize
spawn(function() initialize() end)
